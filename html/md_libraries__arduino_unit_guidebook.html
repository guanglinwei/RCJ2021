<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Spongebot Robocup Junior Soccer 2021: ArduinoUnit Guidebook: The Zen of Testing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Spongebot Robocup Junior Soccer 2021
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ArduinoUnit Guidebook: The Zen of Testing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md48"></a>
Who</h1>
<p>If you are already familiar with testing, I suggest you skip to <b>Making A Reliable Thing</b>, which addresses specific details about using ArduinoUnit and some suggested patterns of using it to solve common problems in embedded system design.</p>
<p>If you are a total beginner, welcome! There are some entry requirements, however. I do expect that you have worked with Arduino's at least a little, and have solved some problem with it (perhaps as a school assignment, or just because you like this kind of stuff).</p>
<p>If you don't know about <code>setup()</code> and <code>loop()</code> and <code>pinMode()</code>, then get your green belt first. Seek out some tutorials on using Arduino and Arduino-like systems elsewhere. Wax on. Wax off.</p>
<p>If you have stared at a little Arduino board you are nurturing to life and wondered </p><pre class="fragment">What is going on in there, why isn't the servo moving?
</pre><p> then you are our kind of people.</p>
<h1><a class="anchor" id="autotoc_md49"></a>
Why</h1>
<p>Building reliable embedded software is a rewarding experience. Some important challenges are:</p>
<ul>
<li>Resources are limited. Where a typical developer can use a pre-built library, an embedded developer might have to craft a specialized tool.</li>
<li>Systems are dark. Larger systems can log everything. Embedded devices often can just keep up with what they need to do, and spending resources logging events can break what they do. Stepping through with a debugger may be impossible, or just hard because of all the real-time events the device interacts with.</li>
<li>Hardware is specific. A real time clock that drives an interrupt on an 8-bit micro-controller which is controlling a coil that drives a metronome who's position is measured by an analog hall-effect sensor has many points of failure that is not easy to identify as "software". But are part of the system and can cause the system to fail none the less. [If you think there is a difference between hardware and software, explain why all the transistors your "software" runs on is different philosophically from a hall effect sensor. (Answer: you may have been trained to ignore one of them)]</li>
<li>Time and money are short. Projects are almost universally wanted quickly and cheaply.</li>
</ul>
<p>ArduinoUnit does not instantly change any of these. But</p>
<ul>
<li>ArduinoUnit is designed to be small so it can work in tiny systems.</li>
<li>Tests can show what does and does not work. ArduinoUnit does this with as little as a serial port. ArduinoUnit can also run "en vitro" on the development environment, where it is easier to discover what is wrong.</li>
<li>ArduinoUnit was originally designed to run "en vivo" on the actual embedded hardware, where any system specific components can be tested and used. This means your tests can include any specific idiosyncrasies about your embedded design.</li>
<li>Testing saves time and money (and stress). It is really the only possibility for delivering reliable solutions to complex problems.</li>
<li>ArduinoUnit is MIT licensed, so it is free for both open and closed-source applications with no viral clauses to make any lawyers you know nervous.</li>
</ul>
<p>Writing software can be hard. Why make it harder by adding tests to the problem: </p><pre class="fragment">Writing incorrect code is easy, but useless.
</pre><p> And </p><pre class="fragment">Writing correct code __without__ tests is really hard.
</pre><p> Software for embedded systems is challenging, so bringing your best game is a good idea. It also builds skills you can use in all your software walks of life.</p>
<h1><a class="anchor" id="autotoc_md50"></a>
What</h1>
<p>What kinds of tests are useful?</p>
<ul>
<li><b>Configuration</b> Is some important startup requirement missing? (Like the BIOS Power On Self <a class="el" href="class_test.html">Test</a>)</li>
<li><b>Status</b> Are there device/component failures? (Like a Low battery indicator)</li>
<li><b>Input</b> Are there input failures? (Like missing/corrupted messages, or bad parameters for a function value)</li>
<li><b>Output</b> Are there output failures? Are results of functions within bounds (Like a Kelvin temperature must be positive), or formats correct?</li>
<li><b>State</b> Is the current state sane? (Does the IMU think we are traveling slower than the speed of light)</li>
<li><b>Time</b> Is something taking too long to compute?</li>
<li><b>Space</b> Is something taking too much room to store?</li>
</ul>
<h1><a class="anchor" id="autotoc_md51"></a>
Test All The Things</h1>
<p>Imagine you are running a hot dog stand. Now imagine trying to do it on a cart that will only roll forward and left, the heater takes 30 minutes to start, the chiller leaks water, and your money box only opens 80% of the time. You will be out of business soon.</p>
<p>A little math is useful here. If you have N independent components, each with reliability P, then the chance all of them work together is Q=P^N. If your system has N=10 parts with P=0.9=90% reliability, then the chance it will all work is Q=P^N=(0.9)^10=0.35=35%. Not a bridge I want to use.</p>
<p>Turns out, if you wanted a Q=99% reliability of a system with N=10 independent components, each component has to be P=Q^(1/N) = (0.99)^(0.1) = 0.999 = 99.9% reliable. </p><pre class="fragment">Solving bigger problems reliably requires more reliable components.
</pre><p> Equate "Thing" and "Unit" in your mind. We solve complicated problems by breaking them up into parts, and then putting those parts together to make bigger parts. Each part is a "unit" that should be tested to make sure it works; so you can reliably use it as a part in a larger unit.</p>
<p><b>A reliable thing works when in good repair and used correctly, and has detectable error status when it is broken or misused.</b></p>
<h1><a class="anchor" id="autotoc_md52"></a>
Some Religion</h1>
<p>Ideally, a unit test will test the suitability of a component for any situation (a bolt should work, no matter what parts they are holding together). Of course real bolts don't always work because of subtleties of the application (heat, cold, vibration, etc).</p>
<p>ArduinoUnit is a non-denominational testing framework: you can use it to make highly independent tests of each component, but you can also build tests that are application specific. Building reliable software requires both. After all, your entire embedded system will likely be a "unit" in someone else's design.</p>
<h1><a class="anchor" id="autotoc_md53"></a>
How to Make a Reliable Thing</h1>
<h2><a class="anchor" id="autotoc_md54"></a>
Step 0: ArduinoUnit basics</h2>
<p>Add the library (Sketch-&gt;Include Library-&gt;Manage Libraries...), find the "basic" example and upload it. Open your serial monitor (9600 baud and you should see some words about tests). Look at the code a bit...</p>
<h3><a class="anchor" id="autotoc_md55"></a>
Serial Port</h3>
<ul>
<li>ArduinoUnit uses <code>Serial</code> by default for reporting. Don't forget to set it up [<code>Serial.begin(baud)</code>], or point it elsewhere [<code><a class="el" href="class_test.html#a33e59751992ec1a8a65745c0b6b144b0">Test::out</a> = &amp;Serial3</code> and <code>Serial3.begin(baud)</code>] in your <code>setup()</code>. Remember to match the baud rate when looking at the serial monitor.</li>
</ul>
<h3><a class="anchor" id="autotoc_md56"></a>
&lt;tt&gt;test/ing()&lt;/tt&gt;</h3>
<ul>
<li><code><a class="el" href="_arduino_unit_8h.html#a191e80e8763446a0e725a8e58fb3380b">test(thingFor)</a> {...}</code> creates a test named <code>thingFor</code> that will be executed once.</li>
<li><code><a class="el" href="_arduino_unit_8h.html#ae8c6ee99d95c8b788bf896974172a7e5">testing(thingFor)</a> {...}</code> creates a test named <code>thingFor</code> that will be executed repeatedly.</li>
<li><code>thingFor</code> can be replaced with any combination of letters, numbers, and underscores (_) but <b>no spaces</b> and must be <b>unique</b> among test/ing(). Good names might be <code>batteryLevel</code> and <code>messageSentOnTime</code>.</li>
<li>All active test &amp; testing blocks are executed in alphabetical order. If you want to control test order you can use test names like <code>000_BatteryLevel</code> and <code>010_MessageSentOnTime</code>.</li>
<li>By default, if a test finishes, it is a <code>pass()</code>. Usually, tests have assertions (discussed next) which (if they fail) have it finish early with a <code>fail()</code> status.</li>
<li>Continuous <code><a class="el" href="_arduino_unit_8h.html#ae8c6ee99d95c8b788bf896974172a7e5">testing()</a></code> tests are called again and again [usually from your <code>loop()</code>]. Forever if that is your thing. You can end them by calling <code>pass()</code> or <code>fail()</code> directly or having an assertion fail.</li>
<li>If all the tests complete, a summary is printed.</li>
</ul>
<p>In a test block <code>{ ... }</code> you can put code. Any code really, but some particularly useful code is</p>
<h3><a class="anchor" id="autotoc_md57"></a>
Verbosity</h3>
<ul>
<li><code>verbosity = TEST_VERBOSITY_ALL</code> to see everything, pass or fail.</li>
</ul>
<h3><a class="anchor" id="autotoc_md58"></a>
&lt;tt&gt;pass()&lt;/tt&gt; or &lt;tt&gt;fail()&lt;/tt&gt;</h3>
<ul>
<li><code>pass()</code> or <code>fail()</code> mark this test as passed or failed. The current test will continue to the end (which may change it's mind), but it will be resolved. This means a <code><a class="el" href="_arduino_unit_8h.html#ae8c6ee99d95c8b788bf896974172a7e5">testing()</a></code> environment will not loop again.</li>
</ul>
<h3><a class="anchor" id="autotoc_md59"></a>
Assertions</h3>
<ul>
<li><code>assert[Relation](a,b[,foot&lt;&lt;note[,retval]])</code> or <code>assertTest[Status](thingFor[,foot&lt;&lt;note[,retval]])</code><ul>
<li><code>[Relation]</code> is one of: <code>Equal</code>, <code>NotEqual</code>, <code>Less</code>, <code>More</code>, <code>LessOrEqual</code>, <code>MoreOrEqual</code>.</li>
<li><code>[Status]</code> is one of: <code>Done</code>, <code>Pass</code>, <code>Skip</code>, <code>Fail</code>, <code>NotDone</code>, <code>NotPass</code>, <code>NotSkip</code>, <code>NotFail</code>.</li>
<li><code>thingFor</code> is some test/testing name.</li>
<li>The <code>&lt;&lt;</code> in the optional <code>foot&lt;&lt;note</code> separates things you can print.</li>
<li>The optional <code>retval</code> is to control the return value (normally nothing) when an assertion fails.</li>
</ul>
</li>
<li>For float and double values, <code>assertNear(a,b,max [,foot &lt;&lt; note])</code> tests <code>|b-a|&lt;=max</code>. If you are working with very large or very small numbers, use <code>assertRelativelyNear</code>, which divides the error by the average magnitude, <code>Â½(|a|+|b|)</code>. Floating point arithmetic is almost never exact so don't expect them to be <code>Equal</code>.</li>
<li><code>checkTest[Status](thingFor)</code> Just true/false depending on the current status of <code>test/ing(thingFor)</code>.</li>
</ul>
<p>The asserts are replaced with code like: </p><pre class="fragment">if (not assertion) { fail(); return retval; }
</pre><p> But also print out a status message (by default only if the assertion fails). For example: </p><pre class="fragment">assertEqual(a[i],b[j],"i="&lt;&lt;i&lt;&lt;",j="&lt;&lt;j);
</pre><p> will generate a message like: </p><pre class="fragment">Assertion failed: (a[i]=3) == (b[j]=4), file sketch.ino, line 17 [i=0,j=2].
</pre><p> With a few tests and asserts in place, you can control them in your <code>setup()</code> and <code>loop()</code>.</p>
<p>Simply:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;ArduinoUnit.h&gt;</div>
<div class="line"> </div>
<div class="line">test(numbers) { assertNotEqual(1,2); }</div>
<div class="line"> </div>
<div class="line">void setup() {</div>
<div class="line">    Serial.begin(9600);</div>
<div class="line">    while (!Serial) {} // Leonardo Serial Mantra</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void loop() {</div>
<div class="line">    Test::run();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Tests that are completed are removed from the list (this is not a dynamic memory thing, trust me), so only the active tests are executed. This means you can have a lot of tests that complete quickly and they represent no run-time overhead once they are resolved.</p>
<h2><a class="anchor" id="autotoc_md60"></a>
Step 1: The Idiot Light</h2>
<p>Pejoratives aside, this idea is really useful and we are all idiots most of the time (there are infinitely more things we don't know than we know). It is important to have a thumbs up/thumbs down status so we can at least decide to look more closely. If you or your manager puckers when they see your code, replace <code>idiot</code> with <code>status</code>. We know what you mean: "Toilet" vs. "Bathroom", it's all the same business.</p>
<p>So let us imagine we are building a controller for a food cart. I'm not going to bother with the implementation, just the tests. By default if a test completes it is a <code>pass()</code>. You can put a fail or some simple assertions to see how the output changes. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;ArduinoUnit.h&gt;</div>
<div class="line"> </div>
<div class="line">test(flash) { /* .. */ }</div>
<div class="line">test(lcd) { /* .. */ }</div>
<div class="line">testing(battery) { /* ..  */ }</div>
<div class="line">testing(heaterRelay) { /* ..  */ }</div>
<div class="line">testing(heaterTempSense) { /* .. */ }</div>
<div class="line">testing(chillerTempSense) { /* .. */ }</div>
<div class="line">testing(hotBinTemp) { /* .. */ }</div>
<div class="line">testing(coldBinTemp) { /* .. */ }</div>
<div class="line"> </div>
<div class="line">const int idiotLightPin = 13;</div>
<div class="line"> </div>
<div class="line">void idiotLightOn() {</div>
<div class="line">  digitalWrite(idiotLightPin,HIGH);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void idiotLightOff() {</div>
<div class="line">  digitalWrite(idiotLightPin,LOW);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void idiotLightFlip() {</div>
<div class="line">  digitalWrite(idiotLightPin,</div>
<div class="line">               ! digitalRead(idiotLightPin));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void idiotLightSetup() {</div>
<div class="line">    pinMode(idiotLightPin, OUTPUT);</div>
<div class="line">    digitalWrite(idiotLightPin, LOW);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//</div>
<div class="line">// blink idiot light 1/sec if any tests fail</div>
<div class="line">//</div>
<div class="line">void idiotLightLoop() {</div>
<div class="line">  static uint32_t next = 0;</div>
<div class="line">  if (Test::getCurrentFailed() &gt; 0</div>
<div class="line">      &amp;&amp; (next == 0 || int32_t(millis()-next) &gt;= 0)) {</div>
<div class="line">    next=millis()+1000;</div>
<div class="line">    idiotLightFlip();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void testSetup() {</div>
<div class="line">  idiotLightOn();</div>
<div class="line"> </div>
<div class="line">  // first run sets up tests (usually nothing)</div>
<div class="line">  Test::run();</div>
<div class="line"> </div>
<div class="line">  idiotLightOff();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void testLoop() {</div>
<div class="line">  Test::run();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">void setup() {</div>
<div class="line">  Serial.begin(115200L);</div>
<div class="line">  while (!Serial) {} // Leonardo/Due Mantra</div>
<div class="line"> </div>
<div class="line">  idiotLightSetup();</div>
<div class="line">  </div>
<div class="line">  // ...</div>
<div class="line">  </div>
<div class="line">  testSetup();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void loop() {</div>
<div class="line">  idiotLightLoop();</div>
<div class="line">  </div>
<div class="line">  // ...</div>
<div class="line">  </div>
<div class="line">  testLoop();</div>
<div class="line">}</div>
</div><!-- fragment --><p>If all your sensors are disconnected but you want to test other things. You can exclude sensor tests (hopefully temporarily) with</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void testSetup() {</div>
<div class="line">    Test::exclude(&quot;*Sense&quot;);</div>
<div class="line">    Test::run();</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you <b>only</b> wanted to test sensors, then:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void testSetup() {</div>
<div class="line">    Test::exclude(&quot;*&quot;);</div>
<div class="line">    Test::include(&quot;*Sense&quot;);</div>
<div class="line">    Test::run();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md61"></a>
Step 2: The Power On Self Test</h2>
<p>If your thing can't run without certain things, you should make sure those certain things are ok or just stop. Add the following:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">// alphabetically last test</div>
<div class="line">// (declaration order does not matter)</div>
<div class="line">test(zzzz_powerOnSelfTest) {</div>
<div class="line">  assertTestPass(flash);</div>
<div class="line">  assertTestPass(lcd);  </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void powerOnSelfTest() {</div>
<div class="line">  uint8_t saveVerbosity = Test::min_verbosity;</div>
<div class="line"> </div>
<div class="line">  // get reports on pass/fail &amp; skipped tests...</div>
<div class="line">  Test::min_verbosity =</div>
<div class="line">    TEST_VERBOSITY_TESTS_ALL | TEST_VERBOSITY_ASSERTIONS_FAILED;</div>
<div class="line"> </div>
<div class="line">  // run tests until the post test is complete</div>
<div class="line">  while (!checkTestDone(zzzz_powerOnSelfTest)) {</div>
<div class="line">    Test::run();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // halt if post fails</div>
<div class="line">  if (checkTestFail(zzzz_powerOnSelfTest)) {</div>
<div class="line">    while (true) {</div>
<div class="line">      idiotLightFlip();</div>
<div class="line">      delay(1000);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // restore original min_verbosity</div>
<div class="line">  Test::min_verbosity = saveVerbosity;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Then call <code>powerOnSelfTest()</code> as the last step of your test setup:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void testSetup() {</div>
<div class="line">  idiotLightOn();</div>
<div class="line"> </div>
<div class="line">  // include/exclude ...</div>
<div class="line"> </div>
<div class="line">  powerOnSelfTest();</div>
<div class="line"> </div>
<div class="line">  idiotLightOff();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md62"></a>
Step 3: Sanity</h2>
<p>The world can be a wild and wooly place. Your system should revert to some safe state if it can't make sense of it. This uses another library, SoftReset, to reboot the Arduino in the hopes it gets better.</p>
<p>Add the "SoftReset" library to your IDE and include it in your project:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#include &lt;ArduinoUnit.h&gt;</div>
<div class="line">#include &lt;SoftReset.h&gt;</div>
</div><!-- fragment --><p>Add a repeating sanity test:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">testing(sanity) {</div>
<div class="line">  assertTestNotFail(battery);</div>
<div class="line">  assertTestNotFail(heaterRelay);</div>
<div class="line">  assertTestNotFail(heaterTempSense);</div>
<div class="line">  assertTestNotFail(chillerTempSense);  </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void sanityCheck() {</div>
<div class="line">  if (checkTestFail(sanity)) {</div>
<div class="line">    for (int i=5; i&gt;0; --i) {</div>
<div class="line">      idiotLightFlip();</div>
<div class="line">      delay(100*i);</div>
<div class="line">    }</div>
<div class="line">    soft_restart();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Add <code>sanityCheck()</code> to your testLoop():</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void testLoop() {</div>
<div class="line">  Test::run();</div>
<div class="line">  sanityCheck();</div>
<div class="line">}</div>
</div><!-- fragment --><p>At this point, you might be testing too often [every <code>loop()</code>]. You can add some timing to test only so often:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line"> </div>
<div class="line">// run repeated tests &amp; sanity check every interval ms</div>
<div class="line">void testLoop() {</div>
<div class="line">  const uint16_t interval = 250;</div>
<div class="line">  static uint32_t next = interval;</div>
<div class="line"> </div>
<div class="line">  if (int32_t(micros()-next) &lt; 0) {</div>
<div class="line">    return;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  next += interval;</div>
<div class="line">  Test::run();</div>
<div class="line">  sanityCheck();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md63"></a>
Step 4: IO</h2>
<p>There is a chicken-and-egg problem with I/O. If you have input and output errors, how can you tell there are problems? You can hijack the return value to flip the idiot light on fail:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void packetReceive() {</div>
<div class="line">    assertEqual(packetMessageCrc(), packetComputeCrc(),&quot;io&quot;,idiotLightFlip());</div>
<div class="line">    packetProcess();</div>
<div class="line">}</div>
</div><!-- fragment --><p>If <code>packetRecieve</code> returns somethiing (not just <code>void</code>), there's a sneaky notation you can use:</p>
<p><code>(a,b,c)</code> evaluates <code>a</code>, then <code>b</code>, then is the value of <code>c</code></p>
<p>So:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">int packetReceive() {</div>
<div class="line">    assertEqual(packetMessageCrc(), packetComputeCrc(),&quot;io&quot;,(idiotLightFlip(),-1));</div>
<div class="line">    return packetProcess();</div>
<div class="line">}</div>
</div><!-- fragment --><p>flips the idiot light and returns -1 for <code>packetRecieve</code> if the checksum fails.</p>
<p>By passing a stream reference to IO operations, you can test if specific input and output steps work using the <a class="el" href="struct_mock_stream.html">MockStream</a> to simulate a serial port. It is nice to set the default to the actual destination, so you don't have to type it everywhere:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">int inInt(const char *name, Stream &amp;io=Serial) {</div>
<div class="line">    io.print(&quot;integer &quot;);</div>
<div class="line">    io.print(name);</div>
<div class="line">    io.print(&quot;? &quot;);</div>
<div class="line">    return io.parseInt();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">test(inInt) {</div>
<div class="line">    MockStream ms;</div>
<div class="line">    int xsend = 132;</div>
<div class="line">    ms.input.println(xsend);</div>
<div class="line">    int xrecv = inInt(&quot;x&quot;,ms);</div>
<div class="line">    assertEqual(xsend,xrecv);</div>
<div class="line">    assertEqual(ms.output,&quot;integer x? &quot;);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void useInInt() {</div>
<div class="line">    int a = inInt(&quot;a&quot;);</div>
<div class="line">    int b = inInt(&quot;b&quot;);</div>
<div class="line">    /* ... */</div>
<div class="line">}</div>
</div><!-- fragment --><p>Be careful! <a class="el" href="struct_mock_stream.html">MockStream</a> uses dynamic memory to hold the input and output (they have the features of <code><a class="el" href="class_print.html">Print</a></code> and <code><a class="el" href="class_string.html">String</a></code> if you want to look them up). Your device probably has very little memory, so:</p>
<ul>
<li>Don't create a lot of input or output in your <a class="el" href="_arduino_unit_8h.html#a191e80e8763446a0e725a8e58fb3380b">test(s)</a>. Each test should create and check relatively small (compared to the amount of free static RAM you have) amounts of data.</li>
<li>Declare MockStreams inside tests/functions (not globals) so they can clean themselves up.</li>
</ul>
<h2><a class="anchor" id="autotoc_md64"></a>
Step 5: Time</h2>
<p>It is important to know if something takes too long. The following accounts for your system running long enough to suffer from the 32-bit microsecond counter rolling back through zero.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void timeCritical() {</div>
<div class="line">    const int32_t maxMicros = 10000;</div>
<div class="line">    uint32_t start = micros();</div>
<div class="line">    /* ... */</div>
<div class="line">    assertLess(int32_t(micros()-start),maxMicros);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md65"></a>
Step 6: Space</h2>
<p>Recursion (functions that directly or indirectly use themselves to solve a reduced version of a problem) and dynamic memory (malloc or new operator, or dynamic structures like <a class="el" href="class_string.html">String</a> that use malloc/new) create systems that just run out of room.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">void spaceCritical() {</div>
<div class="line">    const int16_t minBytes = 350;</div>
<div class="line">    assertMore(freeMemory(), minBytes);</div>
<div class="line">    /* ... */</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that there is no guarantee the space can be allocated in one block. The free space list may be fragmented, so you should check the outcome of any dynamic allocation to attempt. Running out of memory is usually a critical failure, so add to your sanity checks:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">bool criticalError = false;</div>
<div class="line"> </div>
<div class="line">test(sanity) {</div>
<div class="line">  assertFalse(criticalError);</div>
<div class="line">  /* ... */</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void critical() {</div>
<div class="line">     criticalError=true;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void dynamic(int bytes) {</div>
<div class="line">   uint8_t *buf = (uint8_t*) malloc(bytes);</div>
<div class="line">   assertNotEqual(buf,0,&quot;memory&quot;,critical());</div>
<div class="line">   /* ... */</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md66"></a>
Meditations on The Heisenberg Uncertainty Principle</h1>
<p>In physics, the Heisenberg Uncertainty Principle makes a specific statement about how well you can know where something is at (position) and simultaneously how fast it is moving (velocity). For small particles, this has to do with the impossibility of discovering where something is at without throwing something at it, which of course makes it move.</p>
<p>Stepping away from the finding bowling pins with bowling balls problem, there is a little HUP in many things.</p>
<p>Measuring something often changes it, and tests are a kind of observation of software. Now it is true that writing tests can change how an embedded system runs, and you may have to be careful when you spend time and resources testing so there is enough left to solve your problem.</p>
<p>But.</p>
<p>More importantly, writing tests changes how you write code. Tests <b>observe</b> code, and good tests are so valuable that you will want to adjust your habits so your code is easier to observe (hopefully operating correctly) with tests.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
Serve, don't rule</h2>
<p>Code that insists on doing things one way is hard to test. For example:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">double F;</div>
<div class="line">const int tempPin = 0;</div>
<div class="line">void readTempF() {</div>
<div class="line">    double K = analogRead(tempPin)*1024;</div>
<div class="line">    double C = K-273;</div>
<div class="line">    F=(9/5)*C-32;</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>readTempF</code> is very insistent; marching from the activation of the analog-to-digital converter, to a specific sequence of transformations resulting in what we hope is the Fahrenheit temperature. It is incorrect (most code is initially), but there is little to do discover what part(s) are wrong.</p>
<p>Consider however:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">double tempRaw() { // rule</div>
<div class="line">    return analogRead(tempPin);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">double tempRaw2K(double raw) { // serve</div>
<div class="line">    return raw*1024;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">double tempK2C(double K) { // serve</div>
<div class="line">    return K - 273;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">double tempC2F(double C) { // serve</div>
<div class="line">    return (9/5)*C-32;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">double tempRaw2F(double raw) { // serve</div>
<div class="line">    double K = tempRaw2K(raw);</div>
<div class="line">    double C = tempK2C(K);</div>
<div class="line">    return tempC2F(C);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">float F;</div>
<div class="line"> </div>
<div class="line">void readTempF() { // rule</div>
<div class="line">    float raw = TempRaw();</div>
<div class="line">    F = tempRaw2F(raw);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const int minTempRaw = 100;</div>
<div class="line">const int maxTempRaw = 900;</div>
<div class="line"> </div>
<div class="line">testing(tempRaw) {</div>
<div class="line">    double raw = tempRaw();</div>
<div class="line">    assertLessOrEqual(minTempRaw,raw);</div>
<div class="line">    assertLessOrEqual(raw, maxTempRaw);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">test(tempRaw2K) {</div>
<div class="line">    const float tolerance = 0.01;</div>
<div class="line">    assertNear(tempRaw2K(minTempRaw),0.0,tolerance);</div>
<div class="line">    assertNear(tempRaw2K(maxTempRaw),1000.0,tolerance);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">test(tempK2C) {</div>
<div class="line">    const float tolerance = 0.01;</div>
<div class="line">    const float absZeroC = -273.15;</div>
<div class="line">    assertNear(tempK2C(0.0),absZeroC,tolerance);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">test(tempC2F) {</div>
<div class="line">    const float tolerance = 0.01;</div>
<div class="line">    const float freezeF = 32.0;</div>
<div class="line">    const float boilF = 212.0;</div>
<div class="line">    assertNear(tempC2F(0.0),freezeF,tolerance);</div>
<div class="line">    assertNear(tempC2F(100.0),boilF,tolerance);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Ok, so the first and last parts <code>tempRaw</code> and <code>readTempF</code> are still "rule", since they need to access specific things (the analog sensor and the global temperature F). But all the parts are separated and the parts that can serve many purposes can be well tested. Once the components are tested, it is easier to rely on them for the overall solution. A good compiler will turn them both into the same code as well.</p>
<h2><a class="anchor" id="autotoc_md68"></a>
Slow and Steady Wins the Race</h2>
<p>Solve problems in little parts you can test. Then test the parts put together. Eventually you have a working hot dog cart.</p>
<p>Eventually you will be turning your hot dog cart into a taco stand. Trust me everybody does. So leave in all the little parts and the little tests. This makes changing things much easier.</p>
<h2><a class="anchor" id="autotoc_md69"></a>
A Journey of 1000 Miles Begins With A Map</h2>
<p>Planning every detail ahead of time is a waste of effort. So is just charging into the woods. In software, you build the map with tests. If you don't know how to make a thing work, try writing the tests that should pass when it does work. The tests will help solidify what the Thing really is, including a lot about what it does not have to be.</p>
<h2><a class="anchor" id="autotoc_md70"></a>
Your Momma Writes Better Tests Than You</h2>
<p>You cannot see past your own design. Have other people suggest what needs to be tested. Have other people test it. Take their advice; your mother is usually right. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
